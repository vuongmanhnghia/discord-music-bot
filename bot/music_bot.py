"""
Modern Discord Music Bot with clean architecture
Implements the complete playback flow with proper separation of concerns
"""

import asyncio
import time
from typing import Optional

import discord
from discord.ext import commands
from discord import app_commands

from .config.config import config
from .pkg.logger import logger
from .services.audio_service import audio_service
from .services.playback import playback_service
from .services.playlist_service import PlaylistService
from .domain.entities.library import LibraryManager
from .domain.valueobjects.source_type import SourceType
from .utils.youtube_playlist_handler import YouTubePlaylistHandler
from .utils.interaction_manager import InteractionManager


class MusicBot(commands.Bot):
    def __init__(self):
        # Discord intents
        intents = discord.Intents.default()
        intents.message_content = True
        intents.voice_states = True

        super().__init__(
            command_prefix=config.COMMAND_PREFIX,
            intents=intents,
            help_command=None,
            description="Modern Music Bot with intelligent processing",
        )

        # Initialize playlist services
        self.library_manager = LibraryManager()
        self.playlist_service = PlaylistService(self.library_manager)

        # Track current active playlist for each guild
        self.active_playlists: dict[int, str] = {}

        # Initialize InteractionManager
        self.interaction_manager = InteractionManager()

        # Setup commands
        self._setup_commands()

    async def setup_hook(self):
        """Initialize bot components"""
        try:
            logger.info("üöÄ Initializing bot components...")

            # Start ResourceManager for memory leak prevention
            await audio_service.start_resource_management()
            logger.info("‚úÖ Resource management started")

            # Initialize async processing system
            success = await playback_service.initialize_async_processing(self)
            if success:
                logger.info("‚úÖ Async processing system started")
            else:
                logger.warning("‚ö†Ô∏è Failed to start async processing system")

            # Initialize SmartCache system
            try:
                # Warm cache with popular songs (async, non-blocking)
                asyncio.create_task(self._warm_cache_on_startup())
                logger.info("üöÑ SmartCache initialization started")
            except Exception as e:
                logger.warning(f"Cache warming failed: {e}")

            # Sync slash commands globally only
            try:
                synced = await self.tree.sync()
                logger.info(f"‚úÖ Synced {len(synced)} slash commands globally")

                # Remove guild-specific syncing to avoid rate limits
                # Guild commands will inherit from global commands

            except discord.RateLimited as e:
                logger.warning(
                    f"‚ö†Ô∏è Rate limited while syncing commands. Retry after: {e.retry_after}s"
                )
                await asyncio.sleep(e.retry_after)
                # Retry once
                try:
                    synced = await self.tree.sync()
                    logger.info(f"‚úÖ Retried and synced {len(synced)} slash commands")
                except Exception as retry_e:
                    logger.error(f"‚ùå Failed to sync commands after retry: {retry_e}")
            except discord.HTTPException as e:
                logger.error(f"‚ùå HTTP error syncing commands: {e}")
            except Exception as e:
                logger.error(f"‚ùå Failed to sync slash commands: {e}")

        except Exception as e:
            logger.error(f"‚ùå Failed to initialize bot: {e}")
            raise

    async def on_ready(self):
        """Bot ready event"""
        logger.info(f"üéµ {config.BOT_NAME} is ready!")
        logger.info(f"üìä Connected to {len(self.guilds)} guilds")

        if self.user:
            logger.info(f"üéØ Bot ID: {self.user.id}")

        # Set bot status
        activity = discord.Activity(
            type=discord.ActivityType.listening,
            name="/help | High-quality streaming",
        )
        await self.change_presence(activity=activity)

    async def on_guild_join(self, guild: discord.Guild):
        """Handle joining new guild"""
        logger.info(f"üÜï Joined new guild: {guild.name} (ID: {guild.id})")
        # Guild state is managed by services automatically

    async def on_guild_remove(self, guild: discord.Guild):
        """Handle leaving guild"""
        logger.info(f"üëã Left guild: {guild.name} (ID: {guild.id})")

        # Cleanup audio connections
        await audio_service.disconnect_from_guild(guild.id)

    async def on_command_error(self, ctx: commands.Context, error: Exception):
        """Global command error handler"""
        logger.error(f"Command error in {ctx.command}: {error}")

        if isinstance(error, commands.CommandNotFound):
            embed = discord.Embed(
                title="‚ùå Unknown Command",
                description=f"Command `{ctx.invoked_with}` not found.\nUse `{config.COMMAND_PREFIX}help` to see available commands.",
                color=discord.Color.red(),
            )

        elif isinstance(error, commands.MissingRequiredArgument):
            embed = discord.Embed(
                title="‚ùå Missing Argument",
                description=f"Missing required argument: `{error.param.name}`\nUse `{config.COMMAND_PREFIX}help {ctx.command}` for usage info.",
                color=discord.Color.red(),
            )

        elif isinstance(error, commands.BadArgument):
            embed = discord.Embed(
                title="‚ùå Invalid Argument",
                description=f"Invalid argument provided.\nUse `{config.COMMAND_PREFIX}help {ctx.command}` for usage info.",
                color=discord.Color.red(),
            )

        elif isinstance(error, commands.MissingPermissions):
            embed = discord.Embed(
                title="‚ùå Missing Permissions",
                description="You don't have the required permissions to use this command.",
                color=discord.Color.red(),
            )

        elif isinstance(error, commands.CommandOnCooldown):
            embed = discord.Embed(
                title="‚è∞ Command Cooldown",
                description=f"Command is on cooldown. Try again in {error.retry_after:.1f} seconds.",
                color=discord.Color.orange(),
            )

        # Add rate limit handling
        elif isinstance(error, discord.HTTPException) and error.status == 429:
            retry_after = getattr(
                error, "retry_after", None
            ) or error.response.headers.get("Retry-After", "60")
            embed = discord.Embed(
                title="‚ö†Ô∏è Rate Limited",
                description=f"Bot is being rate limited. Please wait {retry_after} seconds and try again.",
                color=discord.Color.orange(),
            )

        else:
            # Unexpected error
            embed = discord.Embed(
                title="‚ùå Unexpected Error",
                description=f"An unexpected error occurred: {str(error)}",
                color=discord.Color.red(),
            )

            # Log full traceback for debugging
            logger.exception(f"Unexpected command error: {error}")

        try:
            await ctx.send(embed=embed, delete_after=30)
        except discord.HTTPException as send_error:
            if send_error.status == 429:
                # If we're rate limited sending the error message, just log it
                logger.warning(f"Rate limited when sending error message: {send_error}")
            else:
                # Fallback to simple message if embed fails
                try:
                    await ctx.send(f"‚ùå Error: {str(error)}", delete_after=30)
                except discord.HTTPException:
                    pass  # Can't send message, give up

    async def on_voice_state_update(
        self,
        member: discord.Member,
        before: discord.VoiceState,
        after: discord.VoiceState,
    ):
        """Handle voice state changes"""
        # Only handle when someone leaves
        if before.channel and not after.channel and member.guild:
            # No need for _ensure_guild_state method - services handle this automatically
            pass

        voice_client = discord.utils.get(self.voice_clients, guild=member.guild)
        if not voice_client:
            return

        # Check if bot is alone in voice channel
        channel = voice_client.channel
        if (
            channel
            and isinstance(channel, (discord.VoiceChannel, discord.StageChannel))
            and hasattr(channel, "members")
            and len([m for m in channel.members if not m.bot]) == 0
        ):
            if config.STAY_CONNECTED_24_7:
                logger.info(
                    f"Bot is alone in voice channel in {member.guild.name}, but staying connected (24/7 mode)"
                )
                # üéµ 24/7 Mode: Bot stays connected for continuous music
                # No auto-disconnect - bot remains in channel for 24/7 music service
                # Users can manually use /leave if needed
            else:
                logger.info(
                    f"Bot is alone in voice channel, will disconnect from {member.guild.name}"
                )

                await asyncio.sleep(60)  # Wait 60 seconds

                # Double-check still alone
                if (
                    channel
                    and isinstance(
                        channel, (discord.VoiceChannel, discord.StageChannel)
                    )
                    and hasattr(channel, "members")
                    and len([m for m in channel.members if not m.bot]) == 0
                ):
                    await audio_service.disconnect_from_guild(member.guild.id)

    def _setup_commands(self):
        """Setup all bot slash commands with clean implementation"""

        @self.tree.command(name="ping", description="Ki·ªÉm tra ƒë·ªô tr·ªÖ bot")
        async def ping_bot(interaction: discord.Interaction):
            """üèì Check bot latency"""
            latency_ms = int(self.latency * 1000)
            embed = discord.Embed(
                title="üèì Pong!",
                description=f"ƒê·ªô tr·ªÖ bot: {latency_ms}ms",
                color=discord.Color.blue(),
            )
            await interaction.response.send_message(embed=embed)

        @self.tree.command(name="join", description="Tham gia voice channel")
        async def join_voice(interaction: discord.Interaction):
            # ‚úÖ FIX: Defer immediately ƒë·ªÉ c√≥ th√™m 15 ph√∫t
            await interaction.response.defer()

            try:
                if (
                    isinstance(interaction.user, discord.Member)
                    and interaction.user.voice
                ):
                    channel = interaction.user.voice.channel
                    if isinstance(
                        channel, (discord.VoiceChannel, discord.StageChannel)
                    ):
                        # Connect to voice - c√≥ th·ªÉ m·∫•t v√†i gi√¢y
                        await audio_service.connect_to_channel(channel)

                        embed = discord.Embed(
                            title="üîä ƒê√£ tham gia voice channel",
                            description=f"ƒê√£ k·∫øt n·ªëi t·ªõi **{channel.name}**",
                            color=discord.Color.green(),
                        )

                        # ‚úÖ Use followup thay v√¨ response (v√¨ ƒë√£ defer)
                        await interaction.followup.send(embed=embed)

                    else:
                        await interaction.followup.send(
                            "‚ùå Kh√¥ng th·ªÉ tham gia channel n√†y!", ephemeral=True
                        )
                else:
                    await interaction.followup.send(
                        "‚ùå H√£y tham gia voice channel tr∆∞·ªõc!", ephemeral=True
                    )

            except Exception as e:
                logger.error(f"Error in join command: {e}")
                try:
                    await interaction.followup.send(
                        f"‚ùå L·ªói khi tham gia voice channel: {str(e)}",
                        ephemeral=True,
                    )
                except:
                    # N·∫øu followup c≈©ng fail, log error
                    logger.error("Failed to send error message to user")

        @self.tree.command(name="leave", description="R·ªùi voice channel")
        async def leave_voice(interaction: discord.Interaction):
            """üëã Leave voice channel"""
            if not interaction.guild:
                await interaction.response.send_message(
                    "‚õî Bot ch∆∞a k·∫øt n·ªëi voice!", ephemeral=True
                )
                return

            success = await audio_service.disconnect_from_guild(interaction.guild.id)

            if success:
                embed = discord.Embed(
                    title="ƒê√£ ng·∫Øt k·∫øt n·ªëi voice channel",
                    description=f"{config.BOT_NAME} „Éª /help",
                    color=discord.Color.blue(),
                )
            else:
                embed = discord.Embed(
                    title="Ch∆∞a k·∫øt n·ªëi",
                    description=f"{config.BOT_NAME} „Éª /help",
                    color=discord.Color.red(),
                )
            await interaction.response.send_message(embed=embed)

        @self.tree.command(
            name="play",
            description="Ph√°t nh·∫°c t·ª´ URL/t√¨m ki·∫øm ho·∫∑c t·ª´ playlist hi·ªán t·∫°i",
        )
        @app_commands.describe(
            query="URL ho·∫∑c t·ª´ kh√≥a t√¨m ki·∫øm (ƒë·ªÉ tr·ªëng ƒë·ªÉ ph√°t t·ª´ playlist hi·ªán t·∫°i)"
        )
        @app_commands.checks.cooldown(
            1, 3.0, key=lambda i: (i.guild_id, i.user.id)
        )  # 3 second cooldown per user per guild
        async def play_music(
            interaction: discord.Interaction, query: Optional[str] = None
        ):
            """‚ñ∂Ô∏è Play music from URL/search query or from active playlist"""
            if not interaction.guild:
                await interaction.response.send_message(
                    "‚õî Bot ch∆∞a k·∫øt n·ªëi voice!", ephemeral=True
                )
                return

            # Input validation for query
            if query:
                # Length check to prevent abuse
                if len(query) > 500:
                    await interaction.response.send_message(
                        "‚ùå Query qu√° d√†i! Gi·ªõi h·∫°n 500 k√Ω t·ª±.", ephemeral=True
                    )
                    return

                # Sanitize query
                query = query.strip()
                if not query:
                    query = None

            # Ensure bot is connected to voice
            if not audio_service.is_connected(interaction.guild.id):
                if (
                    isinstance(interaction.user, discord.Member)
                    and interaction.user.voice
                ):
                    channel = interaction.user.voice.channel
                    if isinstance(
                        channel, (discord.VoiceChannel, discord.StageChannel)
                    ):
                        await audio_service.connect_to_channel(channel)
                    else:
                        await interaction.response.send_message(
                            "‚ùå Kh√¥ng th·ªÉ tham gia channel n√†y!", ephemeral=True
                        )
                        return
                else:
                    await interaction.response.send_message(
                        "H√£y tham gia voice channel tr∆∞·ªõc!", ephemeral=True
                    )
                    return

            # Handle two modes: with query or from active playlist
            if query:
                # Mode 1: Play from URL/search query
                # Check if it's a YouTube playlist

                if YouTubePlaylistHandler.is_playlist_url(query):
                    # Handle YouTube playlist - use InteractionManager for long operation
                    async def process_youtube_playlist():
                        # Extract playlist videos
                        success, video_urls, message = (
                            await YouTubePlaylistHandler.extract_playlist_videos(query)
                        )

                        if not success or not video_urls:
                            return discord.Embed(
                                title="‚ùå Playlist Error",
                                description=message,
                                color=discord.Color.red(),
                            )

                        return await self._process_playlist_videos(
                            video_urls,
                            message,
                            interaction.guild.id,
                            str(interaction.user),
                        )

                    result = await self.interaction_manager.handle_long_operation(
                        interaction,
                        process_youtube_playlist,
                        "üéµ Processing YouTube Playlist...",
                    )
                    return
                else:
                    # Regular single video/search - existing logic
                    await interaction.response.send_message(
                        f"üîç **{query[:50]}{'...' if len(query) > 50 else ''}**"
                    )
            else:
                # Mode 2: Play from active playlist
                guild_id = interaction.guild.id
                active_playlist = self.active_playlists.get(guild_id)

                if not active_playlist:
                    await interaction.response.send_message(
                        "‚ùå Ch∆∞a c√≥ playlist n√†o ƒë∆∞·ª£c ch·ªçn! S·ª≠ d·ª•ng `/use <playlist>` tr∆∞·ªõc ho·∫∑c cung c·∫•p query ƒë·ªÉ t√¨m ki·∫øm.",
                        ephemeral=True,
                    )
                    return

                queue_manager = audio_service.get_queue_manager(guild_id)
                if not queue_manager:
                    await interaction.response.send_message(
                        "‚ùå Kh√¥ng t√¨m th·∫•y queue manager!", ephemeral=True
                    )
                    return

                await interaction.response.defer()

                # Load more songs from active playlist
                success, message = await self.playlist_service.load_playlist_to_queue(
                    active_playlist, queue_manager, str(interaction.user), guild_id
                )

                if success:
                    embed = discord.Embed(
                        title="ƒê√£ load playlist",
                        description=f"üìã **{active_playlist}**\n{message}",
                        color=discord.Color.green(),
                    )

                    # Auto-start playing if not currently playing
                    audio_player = audio_service.get_audio_player(guild_id)
                    if audio_player and not audio_player.is_playing:
                        # Start playing the first song in queue
                        try:
                            started = await audio_service.play_next_song(guild_id)
                            if started:
                                embed.add_field(
                                    name="üéµ Tr·∫°ng th√°i",
                                    value="ƒê√£ b·∫Øt ƒë·∫ßu ph√°t nh·∫°c!",
                                    inline=False,
                                )
                            else:
                                embed.add_field(
                                    name="‚ö†Ô∏è L∆∞u √Ω",
                                    value="ƒê√£ th√™m v√†o queue, nh∆∞ng ch∆∞a c√≥ b√†i n√†o s·∫µn s√†ng ph√°t",
                                    inline=False,
                                )
                        except Exception as e:
                            logger.error(
                                f"Failed to start playback after loading playlist: {e}"
                            )
                            embed.add_field(
                                name="‚ö†Ô∏è L∆∞u √Ω",
                                value="ƒê√£ th√™m v√†o queue, c√≥ l·ªói khi b·∫Øt ƒë·∫ßu ph√°t",
                                inline=False,
                            )
                else:
                    embed = discord.Embed(
                        title="‚ùå L·ªói", description=message, color=discord.Color.red()
                    )

                await interaction.followup.send(embed=embed)
                return

            try:
                # Process the play request using smart caching for faster response
                success, response_message, song = (
                    await playback_service.play_request_cached(
                        user_input=query,
                        guild_id=interaction.guild.id,
                        requested_by=str(interaction.user),
                        auto_play=True,
                    )
                )

                if success and song:
                    embed = discord.Embed(
                        title="ƒê√£ th√™m v√†o h√†ng ƒë·ª£i",
                        description=response_message,
                        color=discord.Color.green(),
                    )

                    # Add source type info
                    embed.add_field(
                        name="Ngu·ªìn",
                        value=song.source_type.value.title(),
                        inline=True,
                    )

                    embed.add_field(
                        name="Tr·∫°ng th√°i", value=song.status.value.title(), inline=True
                    )

                    if song.metadata:
                        embed.add_field(
                            name="Th·ªùi l∆∞·ª£ng",
                            value=song.duration_formatted,
                            inline=True,
                        )

                    # Update the processing message
                    await interaction.edit_original_response(embed=embed)

                else:
                    embed = discord.Embed(
                        title="‚ùå L·ªói ph√°t nh·∫°c",
                        description=response_message,
                        color=discord.Color.red(),
                    )
                    await interaction.edit_original_response(embed=embed)

            except Exception as e:
                logger.error(f"Error in play command: {e}")
                embed = discord.Embed(
                    title="‚ùå L·ªói kh√¥ng mong mu·ªën",
                    description=f"ƒê√£ x·∫£y ra l·ªói: {str(e)}",
                    color=discord.Color.red(),
                )
                await interaction.edit_original_response(embed=embed)

        @self.tree.command(name="skip", description="B·ªè qua b√†i hi·ªán t·∫°i")
        @app_commands.checks.cooldown(
            1, 2.0, key=lambda i: (i.guild_id, i.user.id)
        )  # 2 second cooldown
        async def skip_song(interaction: discord.Interaction):
            """‚è≠Ô∏è Skip current song"""
            if not interaction.guild:
                await interaction.response.send_message(
                    "‚õî Bot ch∆∞a k·∫øt n·ªëi voice!", ephemeral=True
                )
                return

            if not audio_service.is_connected(interaction.guild.id):
                await interaction.response.send_message(
                    "‚õî Bot ch∆∞a k·∫øt n·ªëi voice!", ephemeral=True
                )
                return

            success = await audio_service.skip_to_next(interaction.guild.id)

            if success:
                embed = discord.Embed(
                    title="ƒê√£ b·ªè qua b√†i hi·ªán t·∫°i",
                    description=f"{config.BOT_NAME} „Éª /help",
                    color=discord.Color.blue(),
                )
            else:
                embed = discord.Embed(
                    title="‚ùå Kh√¥ng c√≥ b√†i n√†o",
                    description="Kh√¥ng c√≥ b√†i n√†o ƒë·ªÉ b·ªè qua",
                    color=discord.Color.red(),
                )
            await interaction.response.send_message(embed=embed)

        @self.tree.command(name="pause", description="T·∫°m d·ª´ng ph√°t")
        async def pause_music(interaction: discord.Interaction):
            """‚è∏Ô∏è Pause current playback"""
            if not interaction.guild:
                await interaction.response.send_message(
                    "üí¢ Ch·ªâ s·ª≠ d·ª•ng trong server!", ephemeral=True
                )
                return

            audio_player = audio_service.get_audio_player(interaction.guild.id)
            if not audio_player:
                await interaction.response.send_message(
                    "‚õî Bot ch∆∞a k·∫øt n·ªëi voice!", ephemeral=True
                )
                return

            success = audio_player.pause()

            if success:
                embed = discord.Embed(
                    title="ƒê√£ t·∫°m d·ª´ng",
                    description=f"{config.BOT_NAME} „Éª /help",
                    color=discord.Color.orange(),
                )
            else:
                embed = discord.Embed(
                    title="Kh√¥ng c√≥ g√¨ ƒëang ph√°t",
                    description="üí¢ C√≥ ƒëang ph√°t nh·∫°c ƒë√¢u m√† t·∫°m d·ª´ng",
                    color=discord.Color.red(),
                )
            await interaction.response.send_message(embed=embed)

        @self.tree.command(name="resume", description="Ti·∫øp t·ª•c ph√°t nh·∫°c")
        async def resume_music(interaction: discord.Interaction):
            """Resume paused playback"""
            if not interaction.guild:
                await interaction.response.send_message(
                    "üí¢ Ch·ªâ s·ª≠ d·ª•ng trong server!", ephemeral=True
                )
                return

            audio_player = audio_service.get_audio_player(interaction.guild.id)
            if not audio_player:
                await interaction.response.send_message(
                    "‚õî Bot ch∆∞a k·∫øt n·ªëi voice!", ephemeral=True
                )
                return

            success = audio_player.resume()

            if success:
                embed = discord.Embed(
                    title="ƒê√£ ti·∫øp t·ª•c ph√°t nh·∫°c",
                    description=f"{config.BOT_NAME} „Éª /help",
                    color=discord.Color.green(),
                )
            else:
                embed = discord.Embed(
                    title=" Kh√¥ng c√≥ g√¨ b·ªã t·∫°m d·ª´ng",
                    description="Kh√¥ng c√≥ nh·∫°c n√†o b·ªã t·∫°m d·ª´ng",
                    color=discord.Color.red(),
                )
            await interaction.response.send_message(embed=embed)

        @self.tree.command(name="stop", description="D·ª´ng v√† x√≥a h√†ng ƒë·ª£i")
        async def stop_music(interaction: discord.Interaction):
            """‚èπÔ∏è Stop playback and clear queue"""
            if not interaction.guild:
                await interaction.response.send_message(
                    "‚õî Bot ch∆∞a k·∫øt n·ªëi voice!", ephemeral=True
                )
                return

            audio_player = audio_service.get_audio_player(interaction.guild.id)
            if not audio_player:
                await interaction.response.send_message(
                    "‚õî Bot ch∆∞a k·∫øt n·ªëi voice!", ephemeral=True
                )
                return

            audio_player.stop()
            queue_manager = audio_service.get_queue_manager(interaction.guild.id)
            if queue_manager:
                queue_manager.clear()
                # Clear playlist loaded tracking since queue is cleared
                self.playlist_service.clear_loaded_playlist_tracking(
                    interaction.guild.id
                )

            embed = discord.Embed(
                title="ƒê√£ d·ª´ng",
                description=f"{config.BOT_NAME} „Éª /help",
                color=discord.Color.red(),
            )
            await interaction.response.send_message(embed=embed)

        @self.tree.command(name="queue", description="Hi·ªÉn th·ªã h√†ng ƒë·ª£i hi·ªán t·∫°i")
        async def show_queue(interaction: discord.Interaction):
            """üìã Show current queue"""
            if not interaction.guild:
                await interaction.response.send_message(
                    "‚õî Bot ch∆∞a k·∫øt n·ªëi voice!", ephemeral=True
                )
                return

            queue_manager = audio_service.get_queue_manager(interaction.guild.id)
            if not queue_manager:
                await interaction.response.send_message(
                    "üö´ Kh√¥ng c√≥ h√†ng ƒë·ª£i n√†o!", ephemeral=True
                )
                return

            current_song = queue_manager.current_song
            upcoming_songs = queue_manager.get_upcoming(limit=10)

            if not current_song and not upcoming_songs:
                embed = discord.Embed(
                    title="Kh√¥ng c√≥ b√†i n√†o trong h√†ng ƒë·ª£i",
                    description=f"{config.BOT_NAME} „Éª /help",
                    color=discord.Color.blue(),
                )
                await interaction.response.send_message(embed=embed)
                return

            embed = discord.Embed(
                title="H√†ng ƒë·ª£i hi·ªán t·∫°i",
                color=discord.Color.blue(),
            )

            # Current song
            if current_song:
                embed.add_field(
                    name="ƒêang ph√°t",
                    value=f"**{current_song.display_name}**",
                    inline=False,
                )

            # Upcoming songs
            if upcoming_songs:
                queue_text = ""
                for i, song in enumerate(upcoming_songs[:10], 1):
                    queue_text += f"{i}. {song.display_name}\n"

                if len(upcoming_songs) > 10:
                    queue_text += f"... v√† {len(upcoming_songs) - 10} b√†i kh√°c"

                embed.add_field(
                    name="Ti·∫øp theo",
                    value=queue_text or "Kh√¥ng c√≥",
                    inline=False,
                )

            await interaction.response.send_message(embed=embed)

        @self.tree.command(name="volume", description="ƒê·∫∑t √¢m l∆∞·ª£ng (0-100)")
        @app_commands.describe(volume="√Çm l∆∞·ª£ng t·ª´ 0 ƒë·∫øn 100")
        async def set_volume(
            interaction: discord.Interaction, volume: Optional[int] = None
        ):
            """üîä Set playback volume (0-100)"""
            if not interaction.guild:
                await interaction.response.send_message(
                    "‚õî Bot ch∆∞a k·∫øt n·ªëi voice!", ephemeral=True
                )
                return

            audio_player = audio_service.get_audio_player(interaction.guild.id)
            if not audio_player:
                await interaction.response.send_message(
                    "‚õî Bot ch∆∞a k·∫øt n·ªëi voice!", ephemeral=True
                )
                return

            if volume is None:
                # Show current volume
                current_volume = int(audio_player.volume * 100)
                embed = discord.Embed(
                    title=f"√Çm l∆∞·ª£ng hi·ªán t·∫°i: {current_volume}%",
                    description=f"{config.BOT_NAME} „Éª /help",
                    color=discord.Color.blue(),
                )
                await interaction.response.send_message(embed=embed)
                return

            # Validate volume
            if volume < 0 or volume > 100:
                await interaction.response.send_message(
                    "üí¢ √Çm l∆∞·ª£ng ch·ªâ c√≥ t·ª´ 0 ƒë·∫øn 100 t·ª´ th√¥i =))", ephemeral=True
                )
                return

            # Set volume
            audio_player.set_volume(volume / 100.0)

            embed = discord.Embed(
                title=f"ƒê√£ ƒë·∫∑t √¢m l∆∞·ª£ng: {volume}%",
                description=f"{config.BOT_NAME} „Éª /help",
                color=discord.Color.green(),
            )
            await interaction.response.send_message(embed=embed)

        @self.tree.command(name="nowplaying", description="Hi·ªÉn th·ªã b√†i ƒëang ph√°t")
        async def now_playing(interaction: discord.Interaction):
            """üéµ Show currently playing song"""
            if not interaction.guild:
                await interaction.response.send_message(
                    "‚õî Bot ch∆∞a k·∫øt n·ªëi voice!", ephemeral=True
                )
                return

            audio_player = audio_service.get_audio_player(interaction.guild.id)
            if not audio_player or not audio_player.current_song:
                await interaction.response.send_message(
                    "üö´ Kh√¥ng c√≥ b√†i n√†o ƒëang ph√°t!", ephemeral=True
                )
                return

            song = audio_player.current_song

            embed = discord.Embed(
                title=f"ƒêang ph√°t: {song.display_name}",
                description=f"{config.BOT_NAME} „Éª /help",
                color=discord.Color.green(),
            )

            # Add metadata if available
            if song.metadata:
                embed.add_field(
                    name="Th·ªùi l∆∞·ª£ng",
                    value=song.duration_formatted,
                    inline=True,
                )

                if song.metadata.artist:
                    embed.add_field(
                        name="Ngh·ªá sƒ©",
                        value=song.metadata.artist,
                        inline=True,
                    )

                if song.metadata.album:
                    embed.add_field(
                        name="Album",
                        value=song.metadata.album,
                        inline=True,
                    )

            embed.add_field(
                name="Tr·∫°ng th√°i",
                value="ƒêang ph√°t" if audio_player.is_playing else "T·∫°m d·ª´ng",
                inline=True,
            )

            embed.add_field(
                name="√Çm l∆∞·ª£ng",
                value=f"{int(audio_player.volume * 100)}%",
                inline=True,
            )

            await interaction.response.send_message(embed=embed)

        @self.tree.command(name="repeat", description="Set repeat mode")
        @app_commands.describe(mode="Repeat mode: off, song, queue")
        async def repeat_mode(interaction: discord.Interaction, mode: str):
            """Set repeat mode for the queue"""
            if not interaction.guild:
                await interaction.response.send_message(
                    "This command can only be used in a server."
                )
                return

            guild_id = interaction.guild.id
            queue_manager = audio_service.get_queue_manager(guild_id)

            if not queue_manager:
                await interaction.response.send_message(
                    "No queue found. Use `/play` first."
                )
                return

            if mode.lower() not in ["off", "song", "queue"]:
                await interaction.response.send_message(
                    "Invalid mode. Use: off, song, or queue"
                )
                return

            queue_manager._repeat_mode = mode.lower()

            mode_names = {
                "off": "T·∫Øt l·∫∑p",
                "song": "L·∫∑p b√†i h√°t",
                "queue": "L·∫∑p h√†ng ƒë·ª£i",
            }

            await interaction.response.send_message(
                f"Repeat mode set to: **{mode_names[mode.lower()]}**"
            )

        # ===============================
        # PLAYLIST COMMANDS
        # ===============================

        @self.tree.command(
            name="use", description="Chuy·ªÉn sang playlist v√† n·∫°p v√†o queue"
        )
        @app_commands.describe(playlist_name="T√™n playlist c·∫ßn n·∫°p")
        async def use_playlist(interaction: discord.Interaction, playlist_name: str):
            """üéµ Load playlist into queue"""
            if not interaction.guild:
                await interaction.response.send_message(
                    "‚õî Bot ch∆∞a k·∫øt n·ªëi voice!", ephemeral=True
                )
                return

            # Check if bot is connected to voice
            if not audio_service.is_connected(interaction.guild.id):
                await interaction.response.send_message(
                    "‚ùå Bot c·∫ßn k·∫øt n·ªëi voice channel tr∆∞·ªõc! S·ª≠ d·ª•ng `/join`",
                    ephemeral=True,
                )
                return

            queue_manager = audio_service.get_queue_manager(interaction.guild.id)
            if not queue_manager:
                await interaction.response.send_message(
                    "‚ùå Kh√¥ng t√¨m th·∫•y queue manager!", ephemeral=True
                )
                return

            # Use InteractionManager for loading playlist operation with LAZY LOADING
            async def load_playlist_operation():
                from .utils.lazy_playlist_loader import PlaylistLoadingStrategy

                # Progress callback for user feedback
                async def progress_callback(message: str):
                    try:
                        # Send progress update via followup
                        await interaction.followup.send(f"üìä {message}", ephemeral=True)
                    except:
                        pass  # Ignore errors in progress updates

                success, message, job_id = (
                    await self.playlist_service.load_playlist_to_queue_lazy(
                        playlist_name,
                        queue_manager,
                        str(interaction.user),
                        interaction.guild.id,
                        strategy=PlaylistLoadingStrategy.IMMEDIATE,  # Load first 3 songs immediately
                        progress_callback=progress_callback,
                    )
                )

                return self._create_lazy_use_playlist_result(
                    success, message, playlist_name, interaction.guild.id, job_id
                )

            result = await self.interaction_manager.handle_long_operation(
                interaction,
                load_playlist_operation,
                f"üéµ Loading playlist '{playlist_name}'...",
            )
            return

        @self.tree.command(name="create", description="T·∫°o playlist m·ªõi")
        @app_commands.describe(name="T√™n playlist")
        async def create_playlist(interaction: discord.Interaction, name: str):
            """üìù Create new playlist"""
            success, message = self.playlist_service.create_playlist(name)

            if success:
                embed = discord.Embed(
                    title=f"T·∫°o playlist **{name}** th√†nh c√¥ng",
                    description=message,
                    color=discord.Color.green(),
                )
            else:
                embed = discord.Embed(
                    title="‚ùå L·ªói", description=message, color=discord.Color.red()
                )

            await interaction.response.send_message(embed=embed)

        @self.tree.command(name="add", description="Th√™m b√†i h√°t v√†o playlist hi·ªán t·∫°i")
        @app_commands.describe(song_input="URL ho·∫∑c t√™n b√†i h√°t")
        async def add_to_active_playlist(
            interaction: discord.Interaction, song_input: str
        ):
            """‚ûï Add song to active playlist (with processing like /play)"""
            if not interaction.guild:
                await interaction.response.send_message(
                    "‚õî Bot ch∆∞a k·∫øt n·ªëi voice!", ephemeral=True
                )
                return

            # Check if there's an active playlist
            guild_id = interaction.guild.id
            active_playlist = self.active_playlists.get(guild_id)

            if not active_playlist:
                await interaction.response.send_message(
                    "‚ùå Ch∆∞a c√≥ playlist n√†o ƒë∆∞·ª£c ch·ªçn! S·ª≠ d·ª•ng `/use <playlist>` tr∆∞·ªõc ho·∫∑c s·ª≠ d·ª•ng `/addto <playlist> <song>`",
                    ephemeral=True,
                )
                return

            # Check if it's a YouTube playlist
            from .utils.youtube_playlist_handler import YouTubePlaylistHandler

            if YouTubePlaylistHandler.is_playlist_url(song_input):
                # Handle YouTube playlist - use InteractionManager for long operation
                async def process_add_playlist():
                    # Extract playlist videos
                    success_playlist, video_urls, message = (
                        await YouTubePlaylistHandler.extract_playlist_videos(song_input)
                    )

                    if not success_playlist or not video_urls:
                        return discord.Embed(
                            title="‚ùå Playlist Error",
                            description=message,
                            color=discord.Color.red(),
                        )

                    return await self._process_add_playlist_videos(
                        video_urls,
                        message,
                        active_playlist,
                        interaction.guild.id,
                        str(interaction.user),
                    )

                result = await self.interaction_manager.handle_long_operation(
                    interaction,
                    process_add_playlist,
                    "üéµ Adding YouTube Playlist to queue and active playlist...",
                )
                return

            # Regular single video/search - existing logic
            # Show processing message
            await interaction.response.send_message(
                f"üîç **Processing:** {song_input[:50]}{'...' if len(song_input) > 50 else ''}"
            )

            try:
                # Step 1: Process song like /play (but without auto_play)
                success, response_message, song = await playback_service.play_request(
                    user_input=song_input,
                    guild_id=interaction.guild.id,
                    requested_by=str(interaction.user),
                    auto_play=False,  # Don't auto-start playback
                )

                if success and song:
                    # Step 2: Add processed song to playlist
                    # Use processed metadata for better title
                    title = song.metadata.title if song.metadata else song_input
                    playlist_success, playlist_message = (
                        self.playlist_service.add_to_playlist(
                            active_playlist,
                            song.original_input,
                            song.source_type,
                            title,
                        )
                    )

                    if playlist_success:
                        embed = discord.Embed(
                            title="‚úÖ ƒê√£ th√™m v√†o playlist v√† queue",
                            description=f"üìã **{active_playlist}**\nüéµ **{song.display_name}**",
                            color=discord.Color.green(),
                        )

                        # Add detailed info like /play
                        embed.add_field(
                            name="Ngu·ªìn",
                            value=song.source_type.value.title(),
                            inline=True,
                        )

                        embed.add_field(
                            name="Tr·∫°ng th√°i",
                            value=song.status.value.title(),
                            inline=True,
                        )

                        if song.metadata:
                            embed.add_field(
                                name="Th·ªùi l∆∞·ª£ng",
                                value=song.duration_formatted,
                                inline=True,
                            )

                        # Show queue position
                        queue_manager = audio_service.get_queue_manager(guild_id)
                        if queue_manager:
                            queue_position = len(queue_manager.get_upcoming()) + 1
                            embed.add_field(
                                name="V·ªã tr√≠ queue",
                                value=f"#{queue_position}",
                                inline=True,
                            )

                    else:
                        embed = discord.Embed(
                            title="‚ö†Ô∏è ƒê√£ th√™m v√†o queue nh∆∞ng l·ªói playlist",
                            description=f"üéµ Song: {song.display_name}\n‚ùå Playlist: {playlist_message}",
                            color=discord.Color.orange(),
                        )

                else:
                    embed = discord.Embed(
                        title="‚ùå L·ªói x·ª≠ l√Ω b√†i h√°t",
                        description=response_message,
                        color=discord.Color.red(),
                    )

                # Update the processing message
                await interaction.edit_original_response(embed=embed)

            except Exception as e:
                logger.error(f"Error in enhanced add command: {e}")
                embed = discord.Embed(
                    title="‚ùå L·ªói kh√¥ng mong mu·ªën",
                    description=f"ƒê√£ x·∫£y ra l·ªói: {str(e)}",
                    color=discord.Color.red(),
                )
                await interaction.edit_original_response(embed=embed)

        @self.tree.command(
            name="addto", description="Th√™m b√†i h√°t v√†o playlist ch·ªâ ƒë·ªãnh"
        )
        @app_commands.describe(
            playlist_name="T√™n playlist", song_input="URL ho·∫∑c t√™n b√†i h√°t"
        )
        async def add_to_specific_playlist(
            interaction: discord.Interaction, playlist_name: str, song_input: str
        ):
            """‚ûï Add song to specific playlist"""

            # Check if it's a YouTube playlist
            from .utils.youtube_playlist_handler import YouTubePlaylistHandler

            if YouTubePlaylistHandler.is_playlist_url(song_input):
                # Handle YouTube playlist
                await interaction.response.defer()

                # Extract playlist videos
                success_playlist, video_urls, message = (
                    await YouTubePlaylistHandler.extract_playlist_videos(song_input)
                )

                if success_playlist and video_urls:
                    # Process each video in playlist
                    added_count = 0
                    failed_count = 0

                    embed = discord.Embed(
                        title="üéµ Processing YouTube Playlist",
                        description=f"{message}\n‚è≥ Adding to playlist '{playlist_name}'...",
                        color=discord.Color.blue(),
                    )

                    # Send initial message
                    await interaction.followup.send(embed=embed)

                    # Process videos
                    for i, video_url in enumerate(
                        video_urls[:50]
                    ):  # Limit to 50 videos
                        try:
                            # Detect source type from input
                            source_type = (
                                SourceType.YOUTUBE
                            )  # Default for playlist videos

                            # Use video URL as title initially, will be updated when processed
                            success, message_single = (
                                self.playlist_service.add_to_playlist(
                                    playlist_name,
                                    video_url,
                                    source_type,
                                    f"Video {i+1}",
                                )
                            )

                            if success:
                                added_count += 1
                            else:
                                failed_count += 1
                                logger.warning(
                                    f"Failed to add video to playlist: {message_single}"
                                )

                            # Update progress every 10 songs
                            if (i + 1) % 10 == 0:
                                progress_embed = discord.Embed(
                                    title="üéµ Processing YouTube Playlist",
                                    description=f"üìã **{playlist_name}**\n"
                                    f"‚úÖ Added: {added_count} videos\n"
                                    f"‚ùå Failed: {failed_count} videos\n"
                                    f"‚è≥ Progress: {i+1}/{len(video_urls)}",
                                    color=discord.Color.blue(),
                                )
                                await interaction.edit_original_response(
                                    embed=progress_embed
                                )

                        except Exception as e:
                            logger.error(
                                f"Error adding playlist video to playlist {playlist_name}: {e}"
                            )
                            failed_count += 1

                    # Final result
                    final_embed = discord.Embed(
                        title=f"ƒê√£ c·∫≠p nh·∫≠t playlist {playlist_name}",
                        description=f"ƒê√£ th√™m: {added_count} b√†i h√°t\n"
                        f"L·ªói: {failed_count} b√†i h√°t\n"
                        f"S·ª≠ d·ª•ng `/playlist {playlist_name}` ƒë·ªÉ xem n·ªôi dung playlist",
                        color=(
                            discord.Color.green()
                            if added_count > 0
                            else discord.Color.red()
                        ),
                    )

                    await interaction.edit_original_response(embed=final_embed)
                    return

                else:
                    # Failed to process playlist
                    embed = discord.Embed(
                        title="‚ùå YouTube Playlist Error",
                        description=message,
                        color=discord.Color.red(),
                    )
                    await interaction.followup.send(embed=embed)
                    return

            # Regular single video/search - existing logic
            # Detect source type from input
            source_type = SourceType.YOUTUBE  # Default
            if "spotify.com" in song_input:
                source_type = SourceType.SPOTIFY
            elif "soundcloud.com" in song_input:
                source_type = SourceType.SOUNDCLOUD
            elif not ("http://" in song_input or "https://" in song_input):
                source_type = SourceType.SEARCH_QUERY

            success, message = self.playlist_service.add_to_playlist(
                playlist_name, song_input, source_type, song_input
            )

            if success:
                embed = discord.Embed(
                    title="‚úÖ ƒê√£ th√™m v√†o playlist",
                    description=message,
                    color=discord.Color.green(),
                )
            else:
                embed = discord.Embed(
                    title="‚ùå L·ªói", description=message, color=discord.Color.red()
                )

            await interaction.response.send_message(embed=embed)

        @self.tree.command(name="remove", description="X√≥a b√†i h√°t kh·ªèi playlist")
        @app_commands.describe(
            playlist_name="T√™n playlist", index="S·ªë th·ª© t·ª± b√†i h√°t (b·∫Øt ƒë·∫ßu t·ª´ 1)"
        )
        async def remove_from_playlist(
            interaction: discord.Interaction, playlist_name: str, index: int
        ):
            """‚ûñ Remove song from playlist"""
            success, message = self.playlist_service.remove_from_playlist(
                playlist_name, index
            )

            if success:
                embed = discord.Embed(
                    title="‚úÖ ƒê√£ x√≥a kh·ªèi playlist",
                    description=message,
                    color=discord.Color.green(),
                )
            else:
                embed = discord.Embed(
                    title="‚ùå L·ªói", description=message, color=discord.Color.red()
                )

            await interaction.response.send_message(embed=embed)

        @self.tree.command(name="playlists", description="Li·ªát k√™ t·∫•t c·∫£ playlist")
        async def list_playlists(interaction: discord.Interaction):
            """üìã List all playlists"""
            playlists = self.playlist_service.list_playlists()

            if not playlists:
                embed = discord.Embed(
                    title="Danh s√°ch playlist",
                    description="**Ch∆∞a c√≥ playlist n√†o. S·ª≠ d·ª•ng `/create` ƒë·ªÉ t·∫°o playlist m·ªõi.**",
                    color=discord.Color.blue(),
                )
            else:
                playlist_text = "\n".join([f"**‚Ä¢ {name}**" for name in playlists])
                embed = discord.Embed(
                    title="Danh s√°ch playlist",
                    description=playlist_text,
                    color=discord.Color.blue(),
                )
                embed.set_footer(text=f"**T·ªïng: {len(playlists)} playlist**")

            await interaction.response.send_message(embed=embed)

        @self.tree.command(name="playlist", description="Hi·ªÉn th·ªã n·ªôi dung playlist")
        @app_commands.describe(name="T√™n playlist")
        async def show_playlist(interaction: discord.Interaction, name: str):
            """üìÑ Show playlist contents"""
            playlist_info = self.playlist_service.get_playlist_info(name)

            if not playlist_info:
                embed = discord.Embed(
                    title="‚ùå Kh√¥ng t√¨m th·∫•y",
                    description=f"Playlist '{name}' kh√¥ng t·ªìn t·∫°i.",
                    color=discord.Color.red(),
                )
            else:
                embed = discord.Embed(
                    title=f"üìÑ Playlist: {playlist_info['name']}",
                    color=discord.Color.blue(),
                )

                embed.add_field(
                    name="Th√¥ng tin",
                    value=f"T·ªïng s·ªë b√†i: {playlist_info['total_songs']}\n"
                    f"T·∫°o: {playlist_info['created_at'].strftime('%d/%m/%Y %H:%M')}\n"
                    f"C·∫≠p nh·∫≠t: {playlist_info['updated_at'].strftime('%d/%m/%Y %H:%M')}",
                    inline=False,
                )

                if playlist_info["entries"]:
                    songs_text = ""
                    for i, entry in enumerate(playlist_info["entries"][:10], 1):
                        songs_text += f"{i}. {entry['title'][:50]}{'...' if len(entry['title']) > 50 else ''}\n"

                    if len(playlist_info["entries"]) > 10:
                        songs_text += (
                            f"... v√† {len(playlist_info['entries']) - 10} b√†i kh√°c"
                        )

                        embed.add_field(
                            name="B√†i h√°t", value=songs_text or "Tr·ªëng", inline=False
                        )
                else:
                    embed.add_field(
                        name="B√†i h√°t", value="Playlist tr·ªëng", inline=False
                    )

            await interaction.response.send_message(embed=embed)

        @self.tree.command(name="delete", description="X√≥a playlist")
        @app_commands.describe(name="T√™n playlist c·∫ßn x√≥a")
        async def delete_playlist(interaction: discord.Interaction, name: str):
            """üóëÔ∏è Delete playlist"""
            success, message = self.playlist_service.delete_playlist(name)

            if success:
                embed = discord.Embed(
                    title=f"ƒê√£ x√≥a playlist {name}",
                    description=message,
                    color=discord.Color.green(),
                )
            else:
                embed = discord.Embed(
                    title="‚ùå L·ªói", description=message, color=discord.Color.red()
                )

            await interaction.response.send_message(embed=embed)

        @self.tree.command(
            name="help",
            description=f"Hi·ªÉn th·ªã th√¥ng tin v·ªÅ {config.BOT_NAME} v√† c√°c t√≠nh nƒÉng",
        )
        async def show_help(interaction: discord.Interaction):
            """‚ùì Show help information"""
            embed = discord.Embed(
                title=f"{config.BOT_NAME} „Éª T·ªïng quan",
                color=discord.Color.blue(),
            )

            # Connection commands
            connection_cmds = [
                f"> **`/join`  - Tham gia voice channel**",
                f"> **`/leave` - R·ªùi voice channel**",
            ]

            embed.add_field(name="", value="\n".join(connection_cmds), inline=False)

            # Playlist commands
            playlist_cmds = [
                f"> **`/use <name>`      - Ch·ªçn playlist v√† n·∫°p playlist v√†o `queue`**",
                f"> **`/create <name>`       - T·∫°o playlist m·ªõi**",
                f"> **`/add <song>`          - Th√™m b√†i v√†o playlist hi·ªán t·∫°i**",
                f"> **`/addto <playlist> <song>` - Th√™m b√†i v√†o playlist ch·ªâ ƒë·ªãnh**",
                f"> **`/remove <name> <#>`   - X√≥a b√†i kh·ªèi playlist**",
                f"> **`/playlists`           - Li·ªát k√™ t·∫•t c·∫£ playlist**",
                f"> **`/playlist <name>`     - Hi·ªÉn th·ªã th√¥ng tin playlist**",
                f"> **`/delete <name>`       - X√≥a playlist**",
            ]

            embed.add_field(
                name="Playlist", value="\n".join(playlist_cmds), inline=False
            )

            # Playback commands
            playback_cmds = [
                f"> **`/play`           - Ph√°t t·ª´ playlist hi·ªán t·∫°i**",
                f"> **`/play <query>`   - Ph√°t nh·∫°c t·ª´ URL/t√¨m ki·∫øm**",
                f"> **`/aplay <url>`    - Ph√°t to√†n b·ªô playlist t·ª´ URL (Async)**",
                f"> **`/pause`          - T·∫°m d·ª´ng ph√°t**",
                f"> **`/resume`         - Ti·∫øp t·ª•c ph√°t**",
                f"> **`/skip`           - B·ªè qua b√†i hi·ªán t·∫°i**",
                f"> **`/stop`           - D·ª´ng v√† x√≥a h√†ng ƒë·ª£i**",
            ]

            embed.add_field(
                name="ƒêi·ªÅu khi·ªÉn", value="\n".join(playback_cmds), inline=False
            )

            # Queue commands
            queue_cmds = [
                f"> **`/queue`           - Hi·ªÉn th·ªã h√†ng ƒë·ª£i hi·ªán t·∫°i**",
                f"> **`/queue_status`    - Hi·ªÉn th·ªã tr·∫°ng th√°i h√†ng ƒë·ª£i**",
                f"> **`/cancel_task`     - H·ªßy t√°c v·ª• x·ª≠ l√Ω ƒëang ch·∫°y**",
                f"> **`/playlist_status` - Hi·ªÉn th·ªã ti·∫øn tr√¨nh loading playlist**",
                f"> **`/cancel_playlist` - H·ªßy loading playlist hi·ªán t·∫°i**",
                f"> **`/nowplaying`      - Hi·ªÉn th·ªã b√†i ƒëang ph√°t**",
                f"> **`/volume <0-100>`  - ƒê·∫∑t √¢m l∆∞·ª£ng**",
                f"> **`/repeat <mode>`   - ƒê·∫∑t ch·∫ø ƒë·ªô l·∫∑p**",
            ]

            embed.add_field(name="Queue", value="\n".join(queue_cmds), inline=False)

            embed.add_field(
                name="Ngu·ªìn h·ªó tr·ª£",
                value="**‚Ä¢ YouTube (Single videos + Playlists)\n‚Ä¢ Spotify [comming soon =))]\n‚Ä¢ SoundCloud [comming soon too =))]**",
                inline=False,
            )

            embed.add_field(
                name="YouTube Playlist Features",
                value="**‚Ä¢ `/play <playlist_url>` - Ph√°t to√†n b·ªô playlist\n‚Ä¢ `/add <playlist_url>` - Th√™m playlist v√†o active playlist\n‚Ä¢ `/addto <name> <playlist_url>` - Th√™m playlist v√†o playlist ch·ªâ ƒë·ªãnh**",
                inline=False,
            )

            await interaction.response.send_message(embed=embed)

        # ===============================
        # üîß Resource Management Commands
        # ===============================

        @self.tree.command(
            name="resources", description="üîß [Admin] Hi·ªÉn th·ªã th·ªëng k√™ t√†i nguy√™n bot"
        )
        async def show_resources(interaction: discord.Interaction):
            """üîß Show bot resource statistics (Admin only)"""

            # Simple admin check (you can enhance this)
            if not interaction.user.guild_permissions.administrator:
                await interaction.response.send_message(
                    "‚ùå Ch·ªâ admin m·ªõi c√≥ quy·ªÅn xem th·ªëng k√™ t√†i nguy√™n!", ephemeral=True
                )
                return

            stats = audio_service.get_resource_stats()

            embed = discord.Embed(
                title="üîß Bot Resource Statistics",
                description="Th·ªëng k√™ s·ª≠ d·ª•ng t√†i nguy√™n v√† hi·ªáu su·∫•t",
                color=discord.Color.blue(),
            )

            # Connection Stats
            embed.add_field(
                name="üéµ Audio Connections",
                value=f"**Active Voice Clients**: {stats['total_voice_clients']}\n"
                f"**Audio Players**: {stats['total_audio_players']}\n"
                f"**Queue Managers**: {stats['total_queue_managers']}\n"
                f"**Connections Created**: {stats['connections_created']}\n"
                f"**Connections Cleaned**: {stats['connections_cleaned']}",
                inline=True,
            )

            # Cache Stats
            embed.add_field(
                name="üíæ Cache Performance",
                value=f"**Cache Size**: {stats['cache_size']}\n"
                f"**Cache Hits**: {stats['cache_hits']}\n"
                f"**Cache Misses**: {stats['cache_misses']}\n"
                f"**Hit Rate**: {stats['cache_hit_rate']:.1f}%",
                inline=True,
            )

            # Cleanup Stats
            embed.add_field(
                name="üßπ Cleanup Statistics",
                value=f"**Memory Cleanups**: {stats['memory_cleanups']}\n"
                f"**Active Connections**: {stats['active_connections']}\n"
                f"**Status**: {'üü¢ Healthy' if stats['active_connections'] < 8 else 'üü° High Usage'}",
                inline=True,
            )

            await interaction.response.send_message(embed=embed, ephemeral=True)

        @self.tree.command(
            name="cleanup", description="üßπ [Admin] Force cleanup idle resources"
        )
        async def force_cleanup(interaction: discord.Interaction):
            """üßπ Force cleanup of idle resources (Admin only)"""

            if not interaction.user.guild_permissions.administrator:
                await interaction.response.send_message(
                    "‚ùå Ch·ªâ admin m·ªõi c√≥ quy·ªÅn force cleanup!", ephemeral=True
                )
                return

            await interaction.response.defer(ephemeral=True)

            try:
                cleanup_stats = await audio_service.force_cleanup_idle_connections()

                embed = discord.Embed(
                    title="üßπ Cleanup Complete",
                    description="ƒê√£ th·ª±c hi·ªán d·ªçn d·∫πp t√†i nguy√™n kh√¥ng s·ª≠ d·ª•ng",
                    color=discord.Color.green(),
                )

                embed.add_field(
                    name="üìä Cleanup Results",
                    value=f"**Expired Cache Items**: {cleanup_stats['expired_cache_items']}\n"
                    f"**Idle Connections Removed**: {cleanup_stats['idle_connections']}\n"
                    f"**Remaining Connections**: {cleanup_stats['total_connections'] - cleanup_stats['idle_connections']}",
                    inline=False,
                )

                await interaction.followup.send(embed=embed, ephemeral=True)

            except Exception as e:
                logger.error(f"Error in force cleanup: {e}")
                await interaction.followup.send(
                    f"‚ùå L·ªói khi cleanup: {str(e)}", ephemeral=True
                )

        @self.tree.command(
            name="cache", description="üöÑ [Admin] Hi·ªÉn th·ªã th·ªëng k√™ cache th√¥ng minh"
        )
        async def show_cache_stats(interaction: discord.Interaction):
            """üöÑ Show smart cache performance statistics (Admin only)"""

            if not interaction.user.guild_permissions.administrator:
                await interaction.response.send_message(
                    "‚ùå Ch·ªâ admin m·ªõi c√≥ quy·ªÅn xem th·ªëng k√™ cache!", ephemeral=True
                )
                return

            try:
                await interaction.response.defer(ephemeral=True)

                cache_stats = await playback_service.get_cache_performance()

                embed = discord.Embed(
                    title="üöÑ Smart Cache Performance",
                    description="Th·ªëng k√™ hi·ªáu su·∫•t cache th√¥ng minh",
                    color=discord.Color.green(),
                )

                # Cache Performance
                embed.add_field(
                    name="üìä Cache Performance",
                    value=f"**Hit Rate**: {cache_stats['hit_rate']:.1f}%\n"
                    f"**Total Requests**: {cache_stats['total_requests']}\n"
                    f"**Cache Hits**: {cache_stats['hits']}\n"
                    f"**Cache Misses**: {cache_stats['misses']}\n"
                    f"**Efficiency Ratio**: {cache_stats['efficiency_ratio']:.1f}%",
                    inline=True,
                )

                # Cache Storage
                embed.add_field(
                    name="üíæ Cache Storage",
                    value=f"**Current Size**: {cache_stats['cache_size']}\n"
                    f"**Max Size**: {cache_stats['max_size']}\n"
                    f"**Popular Songs**: {cache_stats['popular_count']}\n"
                    f"**Evictions**: {cache_stats.get('evictions', 0)}",
                    inline=True,
                )

                # Performance Impact
                time_saved = cache_stats.get("processing_time_saved", 0)
                avg_processing_time = cache_stats.get("average_processing_time", 0)

                embed.add_field(
                    name="‚ö° Performance Impact",
                    value=f"**Time Saved**: {time_saved:.1f}s\n"
                    f"**Avg Processing**: {avg_processing_time:.2f}s\n"
                    f"**Total Processed**: {cache_stats.get('total_processed', 0)}\n"
                    f"**Cache Status**: {'üü¢ Optimal' if cache_stats['hit_rate'] > 50 else 'üü° Building'}",
                    inline=True,
                )

                await interaction.followup.send(embed=embed, ephemeral=True)

            except Exception as e:
                logger.error(f"Error getting cache stats: {e}")
                await interaction.followup.send(
                    f"‚ùå L·ªói khi l·∫•y th·ªëng k√™ cache: {str(e)}", ephemeral=True
                )

        @self.tree.command(
            name="warmcache", description="üî• [Admin] Warm cache v·ªõi b√†i h√°t ph·ªï bi·∫øn"
        )
        async def warm_cache(interaction: discord.Interaction):
            """üî• Warm cache with popular songs (Admin only)"""

            if not interaction.user.guild_permissions.administrator:
                await interaction.response.send_message(
                    "‚ùå Ch·ªâ admin m·ªõi c√≥ quy·ªÅn warm cache!", ephemeral=True
                )
                return

            await interaction.response.defer(ephemeral=True)

            try:
                warmed_count = await playback_service.warm_cache_with_popular()

                embed = discord.Embed(
                    title="üî• Cache Warming Complete",
                    description=f"ƒê√£ warm cache v·ªõi {warmed_count} b√†i h√°t ph·ªï bi·∫øn",
                    color=discord.Color.orange(),
                )

                if warmed_count > 0:
                    embed.add_field(
                        name="üìà Performance Boost",
                        value=f"**Songs Pre-cached**: {warmed_count}\n"
                        f"**Expected Speedup**: ~90% faster response\n"
                        f"**Status**: Cache optimization complete",
                        inline=False,
                    )
                else:
                    embed.add_field(
                        name="‚ÑπÔ∏è Status",
                        value="Kh√¥ng c√≥ b√†i h√°t ph·ªï bi·∫øn m·ªõi ƒë·ªÉ warm cache.\nCache ƒë√£ ƒë∆∞·ª£c t·ªëi ∆∞u h√≥a.",
                        inline=False,
                    )

                await interaction.followup.send(embed=embed, ephemeral=True)

            except Exception as e:
                logger.error(f"Error warming cache: {e}")
                await interaction.followup.send(
                    f"‚ùå L·ªói khi warm cache: {str(e)}", ephemeral=True
                )

        @self.tree.command(
            name="cleancache", description="üßπ [Admin] D·ªçn d·∫πp cache c≈© v√† h·∫øt h·∫°n"
        )
        async def clean_cache(interaction: discord.Interaction):
            """üßπ Clean expired cache entries (Admin only)"""

            if not interaction.user.guild_permissions.administrator:
                await interaction.response.send_message(
                    "‚ùå Ch·ªâ admin m·ªõi c√≥ quy·ªÅn clean cache!", ephemeral=True
                )
                return

            await interaction.response.defer(ephemeral=True)

            try:
                cleanup_stats = await playback_service.cleanup_cache()

                embed = discord.Embed(
                    title="üßπ Cache Cleanup Complete",
                    description="ƒê√£ d·ªçn d·∫πp cache entries c≈© v√† h·∫øt h·∫°n",
                    color=discord.Color.blue(),
                )

                embed.add_field(
                    name="üìä Cleanup Results",
                    value=f"**Expired Entries Removed**: {cleanup_stats['expired_entries_removed']}\n"
                    f"**Current Cache Size**: {cleanup_stats['current_cache_size']}\n"
                    f"**Cleanup Time**: {time.strftime('%H:%M:%S')}",
                    inline=False,
                )

                await interaction.followup.send(embed=embed, ephemeral=True)

            except Exception as e:
                logger.error(f"Error cleaning cache: {e}")
                await interaction.followup.send(
                    f"‚ùå L·ªói khi clean cache: {str(e)}", ephemeral=True
                )

        @self.tree.command(
            name="aplay", description="üöÄ Ph√°t nh·∫°c v·ªõi x·ª≠ l√Ω b·∫•t ƒë·ªìng b·ªô (nhanh h∆°n)"
        )
        @app_commands.describe(
            query="URL YouTube ho·∫∑c t·ª´ kh√≥a t√¨m ki·∫øm",
            priority="M·ª©c ƒë·ªô ∆∞u ti√™n x·ª≠ l√Ω (normal/high/urgent)",
        )
        async def async_play(
            interaction: discord.Interaction,
            query: str,
            priority: Optional[str] = "normal",
        ):
            """üöÄ Play music with async processing for faster response"""

            # Import here to avoid circular import
            from .utils.async_processor import ProcessingPriority

            # Parse priority
            priority_map = {
                "low": ProcessingPriority.LOW,
                "normal": ProcessingPriority.NORMAL,
                "high": ProcessingPriority.HIGH,
                "urgent": ProcessingPriority.URGENT,
            }

            processing_priority = priority_map.get(
                priority.lower(), ProcessingPriority.NORMAL
            )

            # Handle with InteractionManager for timeout prevention
            async def async_play_handler():
                # Check voice connection
                if (
                    not isinstance(interaction.user, discord.Member)
                    or not interaction.user.voice
                ):
                    return (False, "‚ùå B·∫°n c·∫ßn v√†o voice channel tr∆∞·ªõc!")

                voice_channel = interaction.user.voice.channel
                guild_id = interaction.guild_id

                # Connect to voice if not already connected
                if not audio_service.is_connected(guild_id):
                    try:
                        await audio_service.connect_to_voice_channel(voice_channel)
                    except Exception as e:
                        return (False, f"‚ùå Kh√¥ng th·ªÉ k·∫øt n·ªëi voice: {str(e)}")

                # Process with async processing
                success, message, song, task_id = (
                    await playback_service.play_request_async(
                        user_input=query,
                        guild_id=guild_id,
                        requested_by=str(interaction.user),
                        priority=processing_priority,
                        interaction=interaction,
                        auto_play=True,
                    )
                )

                if success and song and task_id:
                    priority_emoji = "üî•" if processing_priority.value >= 3 else "‚ö°"
                    return (True, f"{priority_emoji} {message}\n*Task ID: `{task_id}`*")
                else:
                    return (False, message)

            await self.interaction_manager.handle_long_operation(
                interaction, async_play_handler, "ƒêang x·ª≠ l√Ω y√™u c·∫ßu ph√°t nh·∫°c..."
            )

        @self.tree.command(
            name="queue_status", description="üìä Xem tr·∫°ng th√°i h√†ng ƒë·ª£i x·ª≠ l√Ω"
        )
        async def processing_queue_status(interaction: discord.Interaction):
            """üìä Show processing queue status"""
            await interaction.response.defer(ephemeral=True)

            try:
                guild_id = interaction.guild_id
                queue_info = await playback_service.get_processing_queue_info(guild_id)

                if "error" in queue_info:
                    await interaction.followup.send(
                        f"‚ùå L·ªói: {queue_info['error']}", ephemeral=True
                    )
                    return

                embed = discord.Embed(
                    title="üìä Processing Queue Status",
                    description="Th√¥ng tin h√†ng ƒë·ª£i x·ª≠ l√Ω b√†i h√°t",
                    color=discord.Color.blue(),
                )

                # General queue info
                embed.add_field(
                    name="üéØ Overall Queue",
                    value=f"**Pending**: {queue_info.get('queue_size', 0)}\n"
                    f"**Processing**: {queue_info.get('active_tasks', 0)}\n"
                    f"**Total Processed**: {queue_info.get('total_processed', 0)}",
                    inline=True,
                )

                # Worker stats
                worker_stats = queue_info.get("worker_stats", {})
                if worker_stats:
                    worker_info = []
                    for worker_id, stats in worker_stats.items():
                        status = "üü¢ Active" if stats["is_active"] else "üî¥ Inactive"
                        current = (
                            f" *(Processing: {stats['current_task']})*"
                            if stats["current_task"]
                            else ""
                        )
                        worker_info.append(
                            f"**{worker_id}**: {status}\n"
                            f"Completed: {stats['completed']} | Failed: {stats['failed']}{current}"
                        )

                    embed.add_field(
                        name="üë∑ Workers",
                        value="\n\n".join(
                            worker_info[:3]
                        ),  # Limit to 3 workers for space
                        inline=True,
                    )

                # Guild-specific tasks
                guild_tasks = queue_info.get("guild_tasks", [])
                if guild_tasks:
                    task_info = []
                    for task in guild_tasks[:5]:  # Limit to 5 tasks
                        status_emoji = {
                            "queued": "‚è≥",
                            "processing": "üîÑ",
                            "completed": "‚úÖ",
                            "failed": "‚ùå",
                            "cancelled": "‚èπÔ∏è",
                        }.get(task["status"], "‚ùì")

                        task_info.append(
                            f"{status_emoji} **{task['song'][:30]}...** "
                            f"({task['progress']}%) - {task['priority']}"
                        )

                    embed.add_field(
                        name=f"üéµ Guild Tasks ({len(guild_tasks)})",
                        value="\n".join(task_info),
                        inline=False,
                    )

                # Uptime
                uptime = queue_info.get("uptime")
                if uptime:
                    embed.add_field(
                        name="‚è∞ Uptime",
                        value=str(uptime).split(".")[0],  # Remove microseconds
                        inline=True,
                    )

                await interaction.followup.send(embed=embed, ephemeral=True)

            except Exception as e:
                logger.error(f"Error getting queue status: {e}")
                await interaction.followup.send(
                    f"‚ùå L·ªói khi l·∫•y th√¥ng tin queue: {str(e)}", ephemeral=True
                )

        @self.tree.command(name="cancel_task", description="‚ùå H·ªßy task x·ª≠ l√Ω b√†i h√°t")
        @app_commands.describe(task_id="ID c·ªßa task c·∫ßn h·ªßy")
        async def cancel_processing_task(
            interaction: discord.Interaction, task_id: str
        ):
            """‚ùå Cancel a processing task"""
            await interaction.response.defer(ephemeral=True)

            try:
                success, message = await playback_service.cancel_processing_task(
                    task_id
                )

                if success:
                    embed = discord.Embed(
                        title="‚ùå Task Cancelled",
                        description=f"‚úÖ {message}",
                        color=discord.Color.orange(),
                    )
                else:
                    embed = discord.Embed(
                        title="‚ùå Cancel Failed",
                        description=f"‚ö†Ô∏è {message}",
                        color=discord.Color.red(),
                    )

                await interaction.followup.send(embed=embed, ephemeral=True)

            except Exception as e:
                logger.error(f"Error cancelling task: {e}")
                await interaction.followup.send(
                    f"‚ùå L·ªói khi h·ªßy task: {str(e)}", ephemeral=True
                )

        @self.tree.command(
            name="playlist_status", description="üìä Xem tr·∫°ng th√°i loading playlist"
        )
        async def playlist_loading_status(interaction: discord.Interaction):
            """üìä Show playlist loading status"""
            await interaction.response.defer(ephemeral=True)

            try:
                guild_id = interaction.guild_id
                status = await self.playlist_service.get_playlist_loading_status(
                    guild_id
                )

                if not status:
                    await interaction.followup.send(
                        "‚ÑπÔ∏è Kh√¥ng c√≥ playlist n√†o ƒëang ƒë∆∞·ª£c load", ephemeral=True
                    )
                    return

                embed = discord.Embed(
                    title="üìä Playlist Loading Status",
                    description=f"Tr·∫°ng th√°i loading playlist **{status['playlist_name']}**",
                    color=discord.Color.blue(),
                )

                # Progress info
                progress_percent = (
                    (status["loaded_songs"] / status["total_songs"]) * 100
                    if status["total_songs"] > 0
                    else 0
                )

                embed.add_field(
                    name="üìà Progress",
                    value=f"**Loaded**: {status['loaded_songs']}/{status['total_songs']} ({progress_percent:.1f}%)\n"
                    f"**Failed**: {status['failed_songs']}\n"
                    f"**Remaining Tasks**: {status['remaining_tasks']}",
                    inline=True,
                )

                # Job info
                embed.add_field(
                    name="üè∑Ô∏è Job Info",
                    value=f"**Job ID**: `{status['job_id']}`\n"
                    f"**Strategy**: {status['strategy']}\n"
                    f"**Started**: <t:{int(status['created_at'].timestamp())}:R>",
                    inline=True,
                )

                # Status
                if status["is_complete"]:
                    embed.add_field(
                        name="‚úÖ Status",
                        value="**Complete!** All songs loaded",
                        inline=False,
                    )
                    embed.color = discord.Color.green()
                else:
                    embed.add_field(
                        name="üîÑ Status",
                        value="**In Progress** - Background loading continues",
                        inline=False,
                    )

                await interaction.followup.send(embed=embed, ephemeral=True)

            except Exception as e:
                logger.error(f"Error getting playlist status: {e}")
                await interaction.followup.send(
                    f"‚ùå L·ªói khi l·∫•y tr·∫°ng th√°i playlist: {str(e)}", ephemeral=True
                )

        @self.tree.command(
            name="cancel_playlist", description="‚ùå H·ªßy loading playlist hi·ªán t·∫°i"
        )
        async def cancel_playlist_loading(interaction: discord.Interaction):
            """‚ùå Cancel current playlist loading"""
            await interaction.response.defer(ephemeral=True)

            try:
                guild_id = interaction.guild_id
                success = await self.playlist_service.cancel_playlist_loading(guild_id)

                if success:
                    embed = discord.Embed(
                        title="‚ùå Playlist Loading Cancelled",
                        description="‚úÖ ƒê√£ h·ªßy loading playlist hi·ªán t·∫°i",
                        color=discord.Color.orange(),
                    )
                else:
                    embed = discord.Embed(
                        title="‚ÑπÔ∏è No Loading Job",
                        description="‚ö†Ô∏è Kh√¥ng c√≥ playlist n√†o ƒëang ƒë∆∞·ª£c load",
                        color=discord.Color.blue(),
                    )

                await interaction.followup.send(embed=embed, ephemeral=True)

            except Exception as e:
                logger.error(f"Error cancelling playlist loading: {e}")
                await interaction.followup.send(
                    f"‚ùå L·ªói khi h·ªßy playlist loading: {str(e)}", ephemeral=True
                )

    async def _process_playlist_videos(
        self, video_urls: list, playlist_message: str, guild_id: int, requested_by: str
    ):
        """Helper method to process YouTube playlist videos with progress tracking"""
        added_count = 0
        failed_count = 0

        # Process videos in batches to avoid timeout
        for i, video_url in enumerate(video_urls[:50]):  # Limit to 50 videos
            try:
                success_video, _, song = await playback_service.play_request_cached(
                    user_input=video_url,
                    guild_id=guild_id,
                    requested_by=requested_by,
                    auto_play=(i == 0),  # Auto-play first song only
                )

                if success_video:
                    added_count += 1
                else:
                    failed_count += 1

            except Exception as e:
                logger.error(f"Error processing playlist video {video_url}: {e}")
                failed_count += 1

        # Return final result embed
        final_embed = discord.Embed(
            title="‚úÖ YouTube Playlist Processed",
            description=f"üìã **{playlist_message}**\n"
            f"‚úÖ Successfully added: {added_count} videos\n"
            f"‚ùå Failed: {failed_count} videos",
            color=(discord.Color.green() if added_count > 0 else discord.Color.red()),
        )

        if added_count > 0:
            final_embed.add_field(
                name="üéµ Status",
                value="Started playing!" if added_count > 0 else "Added to queue",
                inline=False,
            )

        return final_embed

    async def _process_add_playlist_videos(
        self,
        video_urls: list,
        playlist_message: str,
        active_playlist: str,
        guild_id: int,
        requested_by: str,
    ):
        """Helper method to process YouTube playlist videos for /add command"""
        added_count = 0
        failed_count = 0
        playlist_added_count = 0

        # Process videos in batches to avoid timeout
        for i, video_url in enumerate(video_urls[:50]):  # Limit to 50 videos
            try:
                # Step 1: Process song like /play (but without auto_play) using smart caching
                success, response_message, song = (
                    await playback_service.play_request_cached(
                        user_input=video_url,
                        guild_id=guild_id,
                        requested_by=requested_by,
                        auto_play=False,  # Don't auto-start playback
                    )
                )

                if success and song:
                    added_count += 1

                    # Step 2: Add processed song to playlist
                    title = song.metadata.title if song.metadata else video_url
                    playlist_success, playlist_message = (
                        self.playlist_service.add_to_playlist(
                            active_playlist,
                            song.original_input,
                            song.source_type,
                            title,
                        )
                    )

                    if playlist_success:
                        playlist_added_count += 1
                else:
                    failed_count += 1

            except Exception as e:
                logger.error(f"Error processing add playlist video {video_url}: {e}")
                failed_count += 1

        # Return final result embed
        final_embed = discord.Embed(
            title=f"‚úÖ ƒê√£ c·∫≠p nh·∫≠t playlist {active_playlist}",
            description=f"üìã **{playlist_message}**\n"
            f"‚úÖ ƒê√£ th√™m v√†o queue: {added_count} b√†i h√°t\n"
            f"‚úÖ ƒê√£ th√™m v√†o playlist: {playlist_added_count} b√†i h√°t\n"
            f"‚ùå L·ªói: {failed_count} b√†i h√°t",
            color=(discord.Color.green() if added_count > 0 else discord.Color.red()),
        )

        return final_embed

    def _create_use_playlist_result(
        self, success: bool, message: str, playlist_name: str, guild_id: int
    ):
        """Helper method to create result embed for /use command"""
        if success:
            # Always track the active playlist for this guild, even if empty
            self.active_playlists[guild_id] = playlist_name

            # Check if playlist was empty
            if "is empty" in message:
                embed = discord.Embed(
                    title="‚úÖ ƒê√£ ch·ªçn playlist tr·ªëng",
                    description=f"üìã **{playlist_name}** ƒë√£ ƒë∆∞·ª£c ƒë·∫∑t l√†m playlist hi·ªán t·∫°i\n"
                    + f"‚ö†Ô∏è {message}\n"
                    + f"üí° S·ª≠ d·ª•ng `/add <song>` ƒë·ªÉ th√™m b√†i h√°t",
                    color=discord.Color.orange(),
                )
            else:
                embed = discord.Embed(
                    title="‚úÖ ƒê√£ load playlist",
                    description=message,
                    color=discord.Color.green(),
                )
        else:
            embed = discord.Embed(
                title="‚ùå L·ªói", description=message, color=discord.Color.red()
            )

        return embed

    def _create_lazy_use_playlist_result(
        self,
        success: bool,
        message: str,
        playlist_name: str,
        guild_id: int,
        job_id: Optional[str],
    ):
        """Helper method to create result embed for lazy /use command"""
        if success:
            # Always track the active playlist for this guild
            self.active_playlists[guild_id] = playlist_name

            embed = discord.Embed(
                title=f"K√≠ch ho·∫°t playlist",
                description=f"**{playlist_name} ƒë√£ ƒë∆∞·ª£c load**\n\n" f"{message}\n\n",
                color=discord.Color.blue(),
            )

            if job_id:
                embed.add_field(
                    name="üìä Lazy Loading Info",
                    value=f"**Job ID**: `{job_id}`\n"
                    f"**Strategy**: Load 3 songs immediately, rest in background\n"
                    f"**Progress**: Use `/playlist_status` to check progress",
                    inline=False,
                )

            embed.set_footer(
                text="üí° First few songs load instantly, others process in background"
            )

        else:
            embed = discord.Embed(
                title="‚ùå L·ªói", description=message, color=discord.Color.red()
            )

        return embed

    async def _warm_cache_on_startup(self):
        """Warm cache with popular content on startup"""
        try:
            # Wait a bit for bot to fully initialize
            await asyncio.sleep(10)

            # Warm cache with popular songs
            warmed_count = await playback_service.warm_cache_with_popular()

            if warmed_count > 0:
                logger.info(
                    f"üî• Startup cache warming completed: {warmed_count} songs cached"
                )
            else:
                logger.info("‚ÑπÔ∏è No popular songs to warm cache with on startup")

        except Exception as e:
            logger.error(f"Error during startup cache warming: {e}")

    async def close(self):
        """Clean shutdown"""
        logger.info("üõë Shutting down bot...")

        try:
            # Shutdown SmartCache system
            await playback_service.shutdown_cache_system()
            logger.info("‚úÖ SmartCache shutdown complete")

            # Cleanup audio connections
            await audio_service.cleanup_all()
            logger.info("‚úÖ Bot shutdown complete")

        except Exception as e:
            logger.error(f"‚ùå Error during shutdown: {e}")

        await super().close()
