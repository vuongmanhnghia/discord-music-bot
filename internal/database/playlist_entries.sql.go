// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: playlist_entries.sql

package database

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const addPlaylistEntry = `-- name: AddPlaylistEntry :one
INSERT INTO playlist_entries (
    playlist_id, 
    original_input, 
    source_type, 
    title, 
    duration_seconds,
    thumbnail_url,
    position, 
    added_by
)
VALUES (
    $1, 
    $2, 
    $3, 
    $4, 
    $5,
    $6,
    COALESCE(
        (SELECT MAX(position) + 1 FROM playlist_entries WHERE playlist_id = $1),
        0
    ),
    $7
)
RETURNING id, playlist_id, original_input, source_type, title, duration_seconds, thumbnail_url, position, added_by, added_at
`

type AddPlaylistEntryParams struct {
	PlaylistID      uuid.UUID `json:"playlist_id"`
	OriginalInput   string    `json:"original_input"`
	SourceType      string    `json:"source_type"`
	Title           *string   `json:"title"`
	DurationSeconds *int32    `json:"duration_seconds"`
	ThumbnailUrl    *string   `json:"thumbnail_url"`
	AddedBy         *string   `json:"added_by"`
}

func (q *Queries) AddPlaylistEntry(ctx context.Context, arg AddPlaylistEntryParams) (*PlaylistEntry, error) {
	row := q.db.QueryRow(ctx, addPlaylistEntry,
		arg.PlaylistID,
		arg.OriginalInput,
		arg.SourceType,
		arg.Title,
		arg.DurationSeconds,
		arg.ThumbnailUrl,
		arg.AddedBy,
	)
	var i PlaylistEntry
	err := row.Scan(
		&i.ID,
		&i.PlaylistID,
		&i.OriginalInput,
		&i.SourceType,
		&i.Title,
		&i.DurationSeconds,
		&i.ThumbnailUrl,
		&i.Position,
		&i.AddedBy,
		&i.AddedAt,
	)
	return &i, err
}

const countPlaylistEntries = `-- name: CountPlaylistEntries :one
SELECT COUNT(*)::int FROM playlist_entries WHERE playlist_id = $1
`

func (q *Queries) CountPlaylistEntries(ctx context.Context, playlistID uuid.UUID) (int32, error) {
	row := q.db.QueryRow(ctx, countPlaylistEntries, playlistID)
	var column_1 int32
	err := row.Scan(&column_1)
	return column_1, err
}

const deletePlaylistEntriesByPlaylistID = `-- name: DeletePlaylistEntriesByPlaylistID :exec
DELETE FROM playlist_entries WHERE playlist_id = $1
`

func (q *Queries) DeletePlaylistEntriesByPlaylistID(ctx context.Context, playlistID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deletePlaylistEntriesByPlaylistID, playlistID)
	return err
}

const deletePlaylistEntry = `-- name: DeletePlaylistEntry :exec
DELETE FROM playlist_entries WHERE id = $1
`

func (q *Queries) DeletePlaylistEntry(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deletePlaylistEntry, id)
	return err
}

const deletePlaylistEntryByInput = `-- name: DeletePlaylistEntryByInput :exec
DELETE FROM playlist_entries 
WHERE playlist_id = $1 AND original_input = $2
`

type DeletePlaylistEntryByInputParams struct {
	PlaylistID    uuid.UUID `json:"playlist_id"`
	OriginalInput string    `json:"original_input"`
}

func (q *Queries) DeletePlaylistEntryByInput(ctx context.Context, arg DeletePlaylistEntryByInputParams) error {
	_, err := q.db.Exec(ctx, deletePlaylistEntryByInput, arg.PlaylistID, arg.OriginalInput)
	return err
}

const entryExistsInPlaylist = `-- name: EntryExistsInPlaylist :one
SELECT EXISTS(
    SELECT 1 FROM playlist_entries 
    WHERE playlist_id = $1 AND original_input = $2
)
`

type EntryExistsInPlaylistParams struct {
	PlaylistID    uuid.UUID `json:"playlist_id"`
	OriginalInput string    `json:"original_input"`
}

func (q *Queries) EntryExistsInPlaylist(ctx context.Context, arg EntryExistsInPlaylistParams) (bool, error) {
	row := q.db.QueryRow(ctx, entryExistsInPlaylist, arg.PlaylistID, arg.OriginalInput)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const getPlaylistEntry = `-- name: GetPlaylistEntry :one
SELECT id, playlist_id, original_input, source_type, title, duration_seconds, thumbnail_url, position, added_by, added_at FROM playlist_entries WHERE id = $1
`

func (q *Queries) GetPlaylistEntry(ctx context.Context, id uuid.UUID) (*PlaylistEntry, error) {
	row := q.db.QueryRow(ctx, getPlaylistEntry, id)
	var i PlaylistEntry
	err := row.Scan(
		&i.ID,
		&i.PlaylistID,
		&i.OriginalInput,
		&i.SourceType,
		&i.Title,
		&i.DurationSeconds,
		&i.ThumbnailUrl,
		&i.Position,
		&i.AddedBy,
		&i.AddedAt,
	)
	return &i, err
}

const getPlaylistEntryByInput = `-- name: GetPlaylistEntryByInput :one
SELECT id, playlist_id, original_input, source_type, title, duration_seconds, thumbnail_url, position, added_by, added_at FROM playlist_entries 
WHERE playlist_id = $1 AND original_input = $2
`

type GetPlaylistEntryByInputParams struct {
	PlaylistID    uuid.UUID `json:"playlist_id"`
	OriginalInput string    `json:"original_input"`
}

func (q *Queries) GetPlaylistEntryByInput(ctx context.Context, arg GetPlaylistEntryByInputParams) (*PlaylistEntry, error) {
	row := q.db.QueryRow(ctx, getPlaylistEntryByInput, arg.PlaylistID, arg.OriginalInput)
	var i PlaylistEntry
	err := row.Scan(
		&i.ID,
		&i.PlaylistID,
		&i.OriginalInput,
		&i.SourceType,
		&i.Title,
		&i.DurationSeconds,
		&i.ThumbnailUrl,
		&i.Position,
		&i.AddedBy,
		&i.AddedAt,
	)
	return &i, err
}

const getPlaylistWithEntries = `-- name: GetPlaylistWithEntries :many
SELECT 
    p.id AS playlist_id,
    p.name AS playlist_name,
    p.guild_id,
    p.created_at AS playlist_created_at,
    pe.id AS entry_id,
    pe.original_input,
    pe.source_type,
    pe.title,
    pe.duration_seconds,
    pe.position,
    pe.added_at AS entry_added_at
FROM playlists p
LEFT JOIN playlist_entries pe ON p.id = pe.playlist_id
WHERE p.name = $1 AND (p.guild_id = $2 OR p.guild_id IS NULL)
ORDER BY pe.position, pe.added_at
`

type GetPlaylistWithEntriesParams struct {
	Name    string  `json:"name"`
	GuildID *string `json:"guild_id"`
}

type GetPlaylistWithEntriesRow struct {
	PlaylistID        uuid.UUID          `json:"playlist_id"`
	PlaylistName      string             `json:"playlist_name"`
	GuildID           *string            `json:"guild_id"`
	PlaylistCreatedAt time.Time          `json:"playlist_created_at"`
	EntryID           pgtype.UUID        `json:"entry_id"`
	OriginalInput     *string            `json:"original_input"`
	SourceType        *string            `json:"source_type"`
	Title             *string            `json:"title"`
	DurationSeconds   *int32             `json:"duration_seconds"`
	Position          *int32             `json:"position"`
	EntryAddedAt      pgtype.Timestamptz `json:"entry_added_at"`
}

func (q *Queries) GetPlaylistWithEntries(ctx context.Context, arg GetPlaylistWithEntriesParams) ([]*GetPlaylistWithEntriesRow, error) {
	rows, err := q.db.Query(ctx, getPlaylistWithEntries, arg.Name, arg.GuildID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetPlaylistWithEntriesRow{}
	for rows.Next() {
		var i GetPlaylistWithEntriesRow
		if err := rows.Scan(
			&i.PlaylistID,
			&i.PlaylistName,
			&i.GuildID,
			&i.PlaylistCreatedAt,
			&i.EntryID,
			&i.OriginalInput,
			&i.SourceType,
			&i.Title,
			&i.DurationSeconds,
			&i.Position,
			&i.EntryAddedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPlaylistEntries = `-- name: ListPlaylistEntries :many
SELECT id, playlist_id, original_input, source_type, title, duration_seconds, thumbnail_url, position, added_by, added_at FROM playlist_entries 
WHERE playlist_id = $1 
ORDER BY position, added_at
`

func (q *Queries) ListPlaylistEntries(ctx context.Context, playlistID uuid.UUID) ([]*PlaylistEntry, error) {
	rows, err := q.db.Query(ctx, listPlaylistEntries, playlistID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*PlaylistEntry{}
	for rows.Next() {
		var i PlaylistEntry
		if err := rows.Scan(
			&i.ID,
			&i.PlaylistID,
			&i.OriginalInput,
			&i.SourceType,
			&i.Title,
			&i.DurationSeconds,
			&i.ThumbnailUrl,
			&i.Position,
			&i.AddedBy,
			&i.AddedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const reorderPlaylistEntry = `-- name: ReorderPlaylistEntry :exec
UPDATE playlist_entries SET position = $2 WHERE id = $1
`

type ReorderPlaylistEntryParams struct {
	ID       uuid.UUID `json:"id"`
	Position int32     `json:"position"`
}

func (q *Queries) ReorderPlaylistEntry(ctx context.Context, arg ReorderPlaylistEntryParams) error {
	_, err := q.db.Exec(ctx, reorderPlaylistEntry, arg.ID, arg.Position)
	return err
}

const updatePlaylistEntry = `-- name: UpdatePlaylistEntry :one
UPDATE playlist_entries
SET title = COALESCE($2, title),
    duration_seconds = COALESCE($3, duration_seconds),
    thumbnail_url = COALESCE($4, thumbnail_url)
WHERE id = $1
RETURNING id, playlist_id, original_input, source_type, title, duration_seconds, thumbnail_url, position, added_by, added_at
`

type UpdatePlaylistEntryParams struct {
	ID              uuid.UUID `json:"id"`
	Title           *string   `json:"title"`
	DurationSeconds *int32    `json:"duration_seconds"`
	ThumbnailUrl    *string   `json:"thumbnail_url"`
}

func (q *Queries) UpdatePlaylistEntry(ctx context.Context, arg UpdatePlaylistEntryParams) (*PlaylistEntry, error) {
	row := q.db.QueryRow(ctx, updatePlaylistEntry,
		arg.ID,
		arg.Title,
		arg.DurationSeconds,
		arg.ThumbnailUrl,
	)
	var i PlaylistEntry
	err := row.Scan(
		&i.ID,
		&i.PlaylistID,
		&i.OriginalInput,
		&i.SourceType,
		&i.Title,
		&i.DurationSeconds,
		&i.ThumbnailUrl,
		&i.Position,
		&i.AddedBy,
		&i.AddedAt,
	)
	return &i, err
}
