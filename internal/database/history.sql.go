// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: history.sql

package database

import (
	"context"

	"github.com/google/uuid"
)

const addToPlayHistory = `-- name: AddToPlayHistory :one
INSERT INTO play_history (
    guild_id, 
    original_input, 
    source_type, 
    title, 
    played_by,
    duration_seconds,
    completed
)
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id, guild_id, original_input, source_type, title, played_by, played_at, duration_seconds, completed
`

type AddToPlayHistoryParams struct {
	GuildID         *string `json:"guild_id"`
	OriginalInput   string  `json:"original_input"`
	SourceType      string  `json:"source_type"`
	Title           *string `json:"title"`
	PlayedBy        *string `json:"played_by"`
	DurationSeconds *int32  `json:"duration_seconds"`
	Completed       *bool   `json:"completed"`
}

func (q *Queries) AddToPlayHistory(ctx context.Context, arg AddToPlayHistoryParams) (*PlayHistory, error) {
	row := q.db.QueryRow(ctx, addToPlayHistory,
		arg.GuildID,
		arg.OriginalInput,
		arg.SourceType,
		arg.Title,
		arg.PlayedBy,
		arg.DurationSeconds,
		arg.Completed,
	)
	var i PlayHistory
	err := row.Scan(
		&i.ID,
		&i.GuildID,
		&i.OriginalInput,
		&i.SourceType,
		&i.Title,
		&i.PlayedBy,
		&i.PlayedAt,
		&i.DurationSeconds,
		&i.Completed,
	)
	return &i, err
}

const addUserFavorite = `-- name: AddUserFavorite :one
INSERT INTO user_favorites (user_id, original_input, source_type, title)
VALUES ($1, $2, $3, $4)
ON CONFLICT (user_id, original_input) DO NOTHING
RETURNING id, user_id, original_input, source_type, title, added_at
`

type AddUserFavoriteParams struct {
	UserID        string  `json:"user_id"`
	OriginalInput string  `json:"original_input"`
	SourceType    string  `json:"source_type"`
	Title         *string `json:"title"`
}

func (q *Queries) AddUserFavorite(ctx context.Context, arg AddUserFavoriteParams) (*UserFavorite, error) {
	row := q.db.QueryRow(ctx, addUserFavorite,
		arg.UserID,
		arg.OriginalInput,
		arg.SourceType,
		arg.Title,
	)
	var i UserFavorite
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.OriginalInput,
		&i.SourceType,
		&i.Title,
		&i.AddedAt,
	)
	return &i, err
}

const clearPlayHistory = `-- name: ClearPlayHistory :exec
DELETE FROM play_history WHERE guild_id = $1
`

func (q *Queries) ClearPlayHistory(ctx context.Context, guildID *string) error {
	_, err := q.db.Exec(ctx, clearPlayHistory, guildID)
	return err
}

const getMostPlayedSongs = `-- name: GetMostPlayedSongs :many
SELECT 
    original_input,
    title,
    source_type,
    COUNT(*) AS play_count,
    MAX(played_at) AS last_played
FROM play_history 
WHERE guild_id = $1
GROUP BY original_input, title, source_type
ORDER BY play_count DESC
LIMIT $2
`

type GetMostPlayedSongsParams struct {
	GuildID *string `json:"guild_id"`
	Limit   int32   `json:"limit"`
}

type GetMostPlayedSongsRow struct {
	OriginalInput string      `json:"original_input"`
	Title         *string     `json:"title"`
	SourceType    string      `json:"source_type"`
	PlayCount     int64       `json:"play_count"`
	LastPlayed    interface{} `json:"last_played"`
}

func (q *Queries) GetMostPlayedSongs(ctx context.Context, arg GetMostPlayedSongsParams) ([]*GetMostPlayedSongsRow, error) {
	rows, err := q.db.Query(ctx, getMostPlayedSongs, arg.GuildID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetMostPlayedSongsRow{}
	for rows.Next() {
		var i GetMostPlayedSongsRow
		if err := rows.Scan(
			&i.OriginalInput,
			&i.Title,
			&i.SourceType,
			&i.PlayCount,
			&i.LastPlayed,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecentPlayHistory = `-- name: GetRecentPlayHistory :many
SELECT id, guild_id, original_input, source_type, title, played_by, played_at, duration_seconds, completed FROM play_history 
WHERE guild_id = $1 
ORDER BY played_at DESC 
LIMIT $2
`

type GetRecentPlayHistoryParams struct {
	GuildID *string `json:"guild_id"`
	Limit   int32   `json:"limit"`
}

func (q *Queries) GetRecentPlayHistory(ctx context.Context, arg GetRecentPlayHistoryParams) ([]*PlayHistory, error) {
	rows, err := q.db.Query(ctx, getRecentPlayHistory, arg.GuildID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*PlayHistory{}
	for rows.Next() {
		var i PlayHistory
		if err := rows.Scan(
			&i.ID,
			&i.GuildID,
			&i.OriginalInput,
			&i.SourceType,
			&i.Title,
			&i.PlayedBy,
			&i.PlayedAt,
			&i.DurationSeconds,
			&i.Completed,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserFavorites = `-- name: GetUserFavorites :many
SELECT id, user_id, original_input, source_type, title, added_at FROM user_favorites 
WHERE user_id = $1 
ORDER BY added_at DESC
`

func (q *Queries) GetUserFavorites(ctx context.Context, userID string) ([]*UserFavorite, error) {
	rows, err := q.db.Query(ctx, getUserFavorites, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*UserFavorite{}
	for rows.Next() {
		var i UserFavorite
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.OriginalInput,
			&i.SourceType,
			&i.Title,
			&i.AddedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const isFavorite = `-- name: IsFavorite :one
SELECT EXISTS(
    SELECT 1 FROM user_favorites WHERE user_id = $1 AND original_input = $2
)
`

type IsFavoriteParams struct {
	UserID        string `json:"user_id"`
	OriginalInput string `json:"original_input"`
}

func (q *Queries) IsFavorite(ctx context.Context, arg IsFavoriteParams) (bool, error) {
	row := q.db.QueryRow(ctx, isFavorite, arg.UserID, arg.OriginalInput)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const markPlayCompleted = `-- name: MarkPlayCompleted :exec
UPDATE play_history SET completed = true WHERE id = $1
`

func (q *Queries) MarkPlayCompleted(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, markPlayCompleted, id)
	return err
}

const removeUserFavorite = `-- name: RemoveUserFavorite :exec
DELETE FROM user_favorites WHERE user_id = $1 AND original_input = $2
`

type RemoveUserFavoriteParams struct {
	UserID        string `json:"user_id"`
	OriginalInput string `json:"original_input"`
}

func (q *Queries) RemoveUserFavorite(ctx context.Context, arg RemoveUserFavoriteParams) error {
	_, err := q.db.Exec(ctx, removeUserFavorite, arg.UserID, arg.OriginalInput)
	return err
}
